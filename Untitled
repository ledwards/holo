import Card from './Card';
import Field from './Field';
import Filter from './Filter';
import Comparator from './Comparator';
import FIELDS from '../constants/fields';


// this concept might be wrong? Maybe FilterQuery only exists if there is a valid query and otherwise its display logic?
// or its all here and the couple view helpers in the tsx file are not needed
class FilterQuery {
  query: string;
  value: string;
  field: Field;
  comparator: Comparator;
  filter: Filter;
  unaliasedField: string;
  unaliasedComparator: string;

  constructor(query: string) {
    this.query = query.trim();

    // iterate through all field + field's comparators combo to find the first match
    FIELDS.map(f => { // TODO: field aliases
      if (query.includes(f.name)) {
        this.field = f;
        this.unaliasedField = f.name;
      }

      f.comparators.map(c => {
        if (this.query.match(`${f.name} ${c.name}`)) { // TODO: aliases, TODO: spacing
          this.comparator = c;
          this.unaliasedComparator = c.name;
          this.value = this.query.replace(`${f.name} ${c.name}`, '').trim();

          if (this.value) {
            this.filter = new Filter(f, c, this.value);
          }
        }
      });
    });
  }

  valid() {
    return this.validField() &&
      this.validComparator() &&
      this.validValue() &&
      typeof this.filter !== 'undefined';
  }

  validField() {
    return typeof this.field !== 'undefined';
  }

  validComparator() {
    return typeof this.comparator !== 'undefined';
  }

  validValue() {
    return typeof this.value !== 'undefined';
  }

  // TODO: Add aliases for values e.g. abbreviations?
  // Handle aliases consistently for all types of aliases?

  execute(cards: Card[]) {
    if (!this.valid()) {
      return cards;
    }

    return this.filter.execute(cards, this.comparator, this.value);
  }
}

export default FilterQuery;
